<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XToolkit: UXToolkitCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Untitled-1_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XToolkit
   &#160;<span id="projectnumber">2020.1</span>
   </div>
   <div id="projectbrief">eXtended blueprint functionalities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_u_x_toolkit_core-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UXToolkitCore Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for UXToolkitCore:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_u_x_toolkit_core.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a299d0b208b75ab10ee534c79fa1f7582"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a299d0b208b75ab10ee534c79fa1f7582">FilterArray</a> (const AActor *Context, TArray&lt; int64 &gt; Array, FString FilterFunctionName, TArray&lt; int64 &gt; &amp;Output)</td></tr>
<tr class="separator:a299d0b208b75ab10ee534c79fa1f7582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efd264f45a1d21a5dae02efe120368a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a4efd264f45a1d21a5dae02efe120368a">QuicksortArray</a> (const AActor *Context, TArray&lt; int64 &gt; Array, FString ComparatorFunctionName, TArray&lt; int64 &gt; &amp;Output)</td></tr>
<tr class="separator:a4efd264f45a1d21a5dae02efe120368a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d76e120177e29a2c7900ea88a1aec1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a39d76e120177e29a2c7900ea88a1aec1">SiftArray</a> (const AActor *Context, TArray&lt; int64 &gt; Array, FString SeaveFunctionName, TArray&lt; int64 &gt; &amp;OutputL, TArray&lt; int64 &gt; &amp;OutputR)</td></tr>
<tr class="separator:a39d76e120177e29a2c7900ea88a1aec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f1e94d8323ccb6b0b585625336708c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ae6f1e94d8323ccb6b0b585625336708c">MergeArrays</a> (const AActor *Context, TArray&lt; int64 &gt; BaseArray, TArray&lt; int64 &gt; MergeArray, FString FilterFunctionName, bool MergeOnlyUnique, TArray&lt; int64 &gt; &amp;Output)</td></tr>
<tr class="separator:ae6f1e94d8323ccb6b0b585625336708c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b26c3e5957e730baf0a9814fa15e1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a95b26c3e5957e730baf0a9814fa15e1e">GetTriangle</a> (const TArray&lt; FVector &gt; &amp;VectorArray, const int &amp;TriangleIndex, FVector &amp;A, FVector &amp;B, FVector &amp;C)</td></tr>
<tr class="separator:a95b26c3e5957e730baf0a9814fa15e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03c1f7bd5c47308501d81abcea7eb70"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ab03c1f7bd5c47308501d81abcea7eb70">GetNumTriangles</a> (const TArray&lt; FVector &gt; &amp;VectorArray, bool &amp;IsValid, int &amp;Result)</td></tr>
<tr class="separator:ab03c1f7bd5c47308501d81abcea7eb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eff3cc5fd81fde1321706fec2a7c03b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a7eff3cc5fd81fde1321706fec2a7c03b">IsValidTriangleIndex</a> (const TArray&lt; FVector &gt; &amp;VectorArray, const int &amp;Index, bool &amp;IsValid)</td></tr>
<tr class="separator:a7eff3cc5fd81fde1321706fec2a7c03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae0cc8738a222f07aeccf85106c1a66"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#aaae0cc8738a222f07aeccf85106c1a66">GetArrayIndexFromTriangleIndex</a> (const int &amp;TriangleIndex, int &amp;ArrayIndex)</td></tr>
<tr class="separator:aaae0cc8738a222f07aeccf85106c1a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762202c1dd6f5aeac63920cb1620a247"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a762202c1dd6f5aeac63920cb1620a247">InsertTriangle</a> (UPARAM(ref) TArray&lt; FVector &gt; &amp;VectorArray, FVector A, FVector B, FVector C, int Index, bool &amp;Success)</td></tr>
<tr class="separator:a762202c1dd6f5aeac63920cb1620a247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add63301f79940807d2b305cdea936b83"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#add63301f79940807d2b305cdea936b83">SetTriangle</a> (UPARAM(ref) TArray&lt; FVector &gt; &amp;VectorArray, FVector A, FVector B, FVector C, int Index, bool &amp;Success)</td></tr>
<tr class="separator:add63301f79940807d2b305cdea936b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b76ade44009f952386010a4a3568b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a55b76ade44009f952386010a4a3568b6">RemoveTriangle</a> (UPARAM(ref) TArray&lt; FVector &gt; &amp;VectorArray, int Index, bool &amp;Success)</td></tr>
<tr class="separator:a55b76ade44009f952386010a4a3568b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5496b9914485ffe9941105942c566c37"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a5496b9914485ffe9941105942c566c37">GetTensorDimensionSizes</a> (const FString &amp;IndexString, TArray&lt; int &gt; &amp;Sizes)</td></tr>
<tr class="separator:a5496b9914485ffe9941105942c566c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e096655d7000040b0b49b321db45f1f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a4e096655d7000040b0b49b321db45f1f">GetTensorSize</a> (const FString &amp;IndexString, int &amp;Size)</td></tr>
<tr class="separator:a4e096655d7000040b0b49b321db45f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171cafbc1bcec676166460ac18abdd69"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a171cafbc1bcec676166460ac18abdd69">IsTensorValid</a> (UPARAM(ref) TArray&lt; int32 &gt; &amp;Array, const FString &amp;TensorIndexString, const FString &amp;TensorDimensionSizesString, bool &amp;IsValid)</td></tr>
<tr class="separator:a171cafbc1bcec676166460ac18abdd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed13e6174058bc79705f2583e7a143d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#aed13e6174058bc79705f2583e7a143d3">IsTensorValidFast</a> (const FString &amp;TensorIndexString, const FString &amp;TensorDimensionSizesString, bool &amp;IsValid)</td></tr>
<tr class="separator:aed13e6174058bc79705f2583e7a143d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162f9496193731fe1a5d016e13b6f2da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a162f9496193731fe1a5d016e13b6f2da">ResizeTensor</a> (UPARAM(ref) TArray&lt; int32 &gt; &amp;Array, const FString &amp;IndexString)</td></tr>
<tr class="separator:a162f9496193731fe1a5d016e13b6f2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321f8783e2c883ead1a6d030091065a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a321f8783e2c883ead1a6d030091065a9">TensorToArrayIndex</a> (const FString &amp;TensorIndexString, const FString &amp;TensorDimensionSizesString, int &amp;ArrayIndex)</td></tr>
<tr class="separator:a321f8783e2c883ead1a6d030091065a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6018474f6742361ea163122868dd8a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#af6018474f6742361ea163122868dd8a2">ArrayToTensorIndex</a> (int ArrayIndex, const FString &amp;TensorDimensionSizesString, FString &amp;TensorIndexString)</td></tr>
<tr class="separator:af6018474f6742361ea163122868dd8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b8203e331582eb2c6b8726ab0ad7a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ae5b8203e331582eb2c6b8726ab0ad7a6">GetTensorItem</a> (UPARAM(ref) TArray&lt; int32 &gt; &amp;Array, const FString &amp;TensorIndexString, const FString &amp;TensorDimensionSizesString, bool &amp;Success, int &amp;ArrayIndex, int32 &amp;Result)</td></tr>
<tr class="separator:ae5b8203e331582eb2c6b8726ab0ad7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ccc14c55eb96b994a7648bb5ba5158"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a57ccc14c55eb96b994a7648bb5ba5158">SetTensorItem</a> (UPARAM(ref) TArray&lt; int32 &gt; &amp;Array, UPARAM(ref) int32 &amp;Value, const FString &amp;TensorIndexString, const FString &amp;TensorDimensionSizesString, bool &amp;Success)</td></tr>
<tr class="separator:a57ccc14c55eb96b994a7648bb5ba5158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b83f43b28d8d7a47169a419827bbf4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ad4b83f43b28d8d7a47169a419827bbf4">GetBarycentricCoordinates</a> (const FVector &amp;Point, const FVector &amp;A, const FVector &amp;B, const FVector &amp;C, FVector &amp;Result)</td></tr>
<tr class="separator:ad4b83f43b28d8d7a47169a419827bbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada97526d809487b048082a0bd7383f22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ada97526d809487b048082a0bd7383f22">DelaunayTriangulation</a> (const TArray&lt; FVector &gt; &amp;Input, EDelaunayAxes Plane, TArray&lt; FVector &gt; &amp;Output)</td></tr>
<tr class="separator:ada97526d809487b048082a0bd7383f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58ffd46ff202d063dbbf4a25e19f8f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ac58ffd46ff202d063dbbf4a25e19f8f8">OffsetPoint</a> (const FVector &amp;Point, const FVector &amp;Direction, float Distance, FVector &amp;Result)</td></tr>
<tr class="separator:ac58ffd46ff202d063dbbf4a25e19f8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2f4e8e1ba5a8f5c8c2919b36f8449b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a7e2f4e8e1ba5a8f5c8c2919b36f8449b">IsFacingPoint</a> (const FVector &amp;Point, const FVector &amp;FacingDirection, const FVector &amp;Other, bool &amp;IsFacing)</td></tr>
<tr class="separator:a7e2f4e8e1ba5a8f5c8c2919b36f8449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa924426c153190b03991262fa3a9ea6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#afa924426c153190b03991262fa3a9ea6">IsInFrontOfActor</a> (const AActor *Actor, const AActor *Other, bool &amp;IsInFront)</td></tr>
<tr class="separator:afa924426c153190b03991262fa3a9ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade219249523fbcc6141aa2d8d7ccb882"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ade219249523fbcc6141aa2d8d7ccb882">IsAboveActor</a> (const AActor *Actor, const AActor *Other, bool &amp;IsAbove)</td></tr>
<tr class="separator:ade219249523fbcc6141aa2d8d7ccb882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf688a165320f737b9bd962a392c5fe5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#acf688a165320f737b9bd962a392c5fe5">IsRightOfActor</a> (const AActor *Actor, const AActor *Other, bool &amp;IsRight)</td></tr>
<tr class="separator:acf688a165320f737b9bd962a392c5fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d962686d23768a0da45ee1ad03a55f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ab8d962686d23768a0da45ee1ad03a55f">IsNearActor</a> (const AActor *Actor, const AActor *Other, float Distance, bool &amp;IsNear)</td></tr>
<tr class="separator:ab8d962686d23768a0da45ee1ad03a55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c73dc69460767159e5e5bf1a054d9f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#af3c73dc69460767159e5e5bf1a054d9f">HexToColor</a> (FString Hex, FColor &amp;Result)</td></tr>
<tr class="separator:af3c73dc69460767159e5e5bf1a054d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf1c128a389381654eed9b240d28314"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a1cf1c128a389381654eed9b240d28314">ChangeColorLightness</a> (const FColor &amp;Color, float Amount, FColor &amp;Result)</td></tr>
<tr class="separator:a1cf1c128a389381654eed9b240d28314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06d178c3ee77c07e91ef1ceb682877"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a6f06d178c3ee77c07e91ef1ceb682877">LightenColor</a> (const FColor &amp;Color, float Amount, FColor &amp;Result)</td></tr>
<tr class="separator:a6f06d178c3ee77c07e91ef1ceb682877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d754cb65a338109fce7869a0cb3b58"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#aa8d754cb65a338109fce7869a0cb3b58">DarkenColor</a> (const FColor &amp;Color, float Amount, FColor &amp;Result)</td></tr>
<tr class="separator:aa8d754cb65a338109fce7869a0cb3b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7427c102bc781bfdc4e5e96be5174eb5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a7427c102bc781bfdc4e5e96be5174eb5">MixColors</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a7427c102bc781bfdc4e5e96be5174eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64c918f158eed3addbfe3cea70b94f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ab64c918f158eed3addbfe3cea70b94f0">MixColorsBiased</a> (const FColor &amp;A, const FColor &amp;B, float Bias, FColor &amp;Result)</td></tr>
<tr class="separator:ab64c918f158eed3addbfe3cea70b94f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad916c8592726d5d10bb2353bb76111fa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ad916c8592726d5d10bb2353bb76111fa">BlendColorsScreen</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:ad916c8592726d5d10bb2353bb76111fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf42897365c404aecd51986830108a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a90bf42897365c404aecd51986830108a">BlendColorsExclusion</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a90bf42897365c404aecd51986830108a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b17648a232c3975e270999569c9dd5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a30b17648a232c3975e270999569c9dd5">BlendColorsOverlay</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a30b17648a232c3975e270999569c9dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97f90b0f4d472e017731c8dc60daa63"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ad97f90b0f4d472e017731c8dc60daa63">BlendColorsSoftLight</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:ad97f90b0f4d472e017731c8dc60daa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3921c6a08ec14cd31c165e56df7f9bbe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a3921c6a08ec14cd31c165e56df7f9bbe">BlendColorsHardLight</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a3921c6a08ec14cd31c165e56df7f9bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149c5e5c4171fb3996c823697b25640d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a149c5e5c4171fb3996c823697b25640d">BlendColorsDodge</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a149c5e5c4171fb3996c823697b25640d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41be19df1493725dbb1cf499d394eb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ac41be19df1493725dbb1cf499d394eb2">BlendColorsBurn</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:ac41be19df1493725dbb1cf499d394eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e0704fae5e1442f999b4b29bceaa72"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a13e0704fae5e1442f999b4b29bceaa72">BlendColorsLinearDodge</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a13e0704fae5e1442f999b4b29bceaa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b9bfe7cb0e777d60b6f6005b77ebd6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a43b9bfe7cb0e777d60b6f6005b77ebd6">BlendColorsLinearBurn</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a43b9bfe7cb0e777d60b6f6005b77ebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f349d562e099547c832df1498bcc064"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a1f349d562e099547c832df1498bcc064">BlendColorsLinearLight</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a1f349d562e099547c832df1498bcc064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb00544da273badbd72f6945ef15b60"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a6cb00544da273badbd72f6945ef15b60">BlendColorsVividLight</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a6cb00544da273badbd72f6945ef15b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44b0a85640e1ba63cb035fef423e1e9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#ac44b0a85640e1ba63cb035fef423e1e9">BlendColorsPinLight</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:ac44b0a85640e1ba63cb035fef423e1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563246e793814b44bae05e625a84d17c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a563246e793814b44bae05e625a84d17c">BlendColorsHardMix</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a563246e793814b44bae05e625a84d17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49cc80a91cf74f365b338071519616c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#af49cc80a91cf74f365b338071519616c">BlendColorsReflect</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:af49cc80a91cf74f365b338071519616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3151c605539393d2b152ce5519449f2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a3151c605539393d2b152ce5519449f2b">BlendColorsGlow</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a3151c605539393d2b152ce5519449f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8b7713431f01ecec86222fa8143a89"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_x_toolkit_core.html#a9a8b7713431f01ecec86222fa8143a89">BlendColorsPhoenix</a> (const FColor &amp;A, const FColor &amp;B, FColor &amp;Result)</td></tr>
<tr class="separator:a9a8b7713431f01ecec86222fa8143a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af6018474f6742361ea163122868dd8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6018474f6742361ea163122868dd8a2">&#9670;&nbsp;</a></span>ArrayToTensorIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::ArrayToTensorIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ArrayIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorDimensionSizesString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString &amp;&#160;</td>
          <td class="paramname"><em>TensorIndexString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a 1D array index to a n-dimensional tensor index. Returns -1 if it fails to convert </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ArrayIndex</td><td>1D array index </td></tr>
    <tr><td class="paramname">TensorDimensionSizesString</td><td>A string representation of the tensor dimension sizes, each dimension must be separated by | an example for a 5d tensor 1|2|3|4|5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TensorIndexString A string representation of the tensor index </dd></dl>

</div>
</div>
<a id="ac41be19df1493725dbb1cf499d394eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41be19df1493725dbb1cf499d394eb2">&#9670;&nbsp;</a></span>BlendColorsBurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsBurn </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color burn function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a149c5e5c4171fb3996c823697b25640d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149c5e5c4171fb3996c823697b25640d">&#9670;&nbsp;</a></span>BlendColorsDodge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsDodge </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color dodge function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a90bf42897365c404aecd51986830108a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf42897365c404aecd51986830108a">&#9670;&nbsp;</a></span>BlendColorsExclusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsExclusion </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with exclusion function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a3151c605539393d2b152ce5519449f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3151c605539393d2b152ce5519449f2b">&#9670;&nbsp;</a></span>BlendColorsGlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsGlow </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color glow function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a3921c6a08ec14cd31c165e56df7f9bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3921c6a08ec14cd31c165e56df7f9bbe">&#9670;&nbsp;</a></span>BlendColorsHardLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsHardLight </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with hard light function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a563246e793814b44bae05e625a84d17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563246e793814b44bae05e625a84d17c">&#9670;&nbsp;</a></span>BlendColorsHardMix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsHardMix </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color hard mix function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a43b9bfe7cb0e777d60b6f6005b77ebd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b9bfe7cb0e777d60b6f6005b77ebd6">&#9670;&nbsp;</a></span>BlendColorsLinearBurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsLinearBurn </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color linear burn function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a13e0704fae5e1442f999b4b29bceaa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e0704fae5e1442f999b4b29bceaa72">&#9670;&nbsp;</a></span>BlendColorsLinearDodge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsLinearDodge </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color linear dodge function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a1f349d562e099547c832df1498bcc064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f349d562e099547c832df1498bcc064">&#9670;&nbsp;</a></span>BlendColorsLinearLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsLinearLight </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color linear light function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a30b17648a232c3975e270999569c9dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b17648a232c3975e270999569c9dd5">&#9670;&nbsp;</a></span>BlendColorsOverlay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsOverlay </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with overlay function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a9a8b7713431f01ecec86222fa8143a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8b7713431f01ecec86222fa8143a89">&#9670;&nbsp;</a></span>BlendColorsPhoenix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsPhoenix </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color phoenix function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="ac44b0a85640e1ba63cb035fef423e1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44b0a85640e1ba63cb035fef423e1e9">&#9670;&nbsp;</a></span>BlendColorsPinLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsPinLight </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color pin light function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="af49cc80a91cf74f365b338071519616c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49cc80a91cf74f365b338071519616c">&#9670;&nbsp;</a></span>BlendColorsReflect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsReflect </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color reflect function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="ad916c8592726d5d10bb2353bb76111fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad916c8592726d5d10bb2353bb76111fa">&#9670;&nbsp;</a></span>BlendColorsScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsScreen </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with screen function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="ad97f90b0f4d472e017731c8dc60daa63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97f90b0f4d472e017731c8dc60daa63">&#9670;&nbsp;</a></span>BlendColorsSoftLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsSoftLight </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with soft light function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a6cb00544da273badbd72f6945ef15b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb00544da273badbd72f6945ef15b60">&#9670;&nbsp;</a></span>BlendColorsVividLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::BlendColorsVividLight </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blends two colors with color vivid light function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a1cf1c128a389381654eed9b240d28314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf1c128a389381654eed9b240d28314">&#9670;&nbsp;</a></span>ChangeColorLightness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::ChangeColorLightness </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>Color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the input color lightness </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Color</td><td>The color to change lightness of </td></tr>
    <tr><td class="paramname">Amount</td><td>-1.0 to 1.0, the amount to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="aa8d754cb65a338109fce7869a0cb3b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d754cb65a338109fce7869a0cb3b58">&#9670;&nbsp;</a></span>DarkenColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::DarkenColor </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>Color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes the input color darker </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Color</td><td>The color to darken </td></tr>
    <tr><td class="paramname">Amount</td><td>0.0 to 1.0, the amount to darken </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="ada97526d809487b048082a0bd7383f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada97526d809487b048082a0bd7383f22">&#9670;&nbsp;</a></span>DelaunayTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::DelaunayTriangulation </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDelaunayAxes&#160;</td>
          <td class="paramname"><em>Plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Triangulates an array of 3D points. The result is an array of points, each tuple of 3 points make up a triangle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>Array of points to triangulate </td></tr>
    <tr><td class="paramname">Plane</td><td>Plane on which to triangulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output The result is an array of points, each tuple of 3 points make up a triangle. For example [0], [1], [2], is one triangle and the next is [3], [4], [5], and so on. </dd></dl>

</div>
</div>
<a id="a299d0b208b75ab10ee534c79fa1f7582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299d0b208b75ab10ee534c79fa1f7582">&#9670;&nbsp;</a></span>FilterArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::FilterArray </td>
          <td>(</td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt;&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString&#160;</td>
          <td class="paramname"><em>FilterFunctionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Filters an array based on the result of the [FilterFunctionName] defined in Blueprints. Removes all elements from the input array that do not satisfy the [FilterFunctionName] result. The BP [FilterFunctionName] must be defined in BP as follows: Inputs: int Index, &lt;InputArrayType&gt; Object; Output: bool RetVal; The BP [FilterFunctionName] will be called each time a filter event happens with the appropriate parameters already set inside the BP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Context</td><td>The actor that is the context of this operation (get Self). </td></tr>
    <tr><td class="paramname">Array</td><td>The array that is the subject of filtration. </td></tr>
    <tr><td class="paramname">FilterFunctionName</td><td>The name of the function which determines whether the current element should remain inside the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output The array that is the result of this filtration. </dd></dl>

</div>
</div>
<a id="aaae0cc8738a222f07aeccf85106c1a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae0cc8738a222f07aeccf85106c1a66">&#9670;&nbsp;</a></span>GetArrayIndexFromTriangleIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::GetArrayIndexFromTriangleIndex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>TriangleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ArrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the first index in the vector array of the specified triangle index </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TriangleIndex</td><td>The index of the triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ArrayIndex The presumed index in the vector array </dd></dl>

</div>
</div>
<a id="ad4b83f43b28d8d7a47169a419827bbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b83f43b28d8d7a47169a419827bbf4">&#9670;&nbsp;</a></span>GetBarycentricCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::GetBarycentricCoordinates </td>
          <td>(</td>
          <td class="paramtype">const FVector &amp;&#160;</td>
          <td class="paramname"><em>Point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVector &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVector &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVector &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the barycentric coordinates of a given point and a given triangle defined by 3 points (A,B,C) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Point</td><td>The point for witch to find the barycentric coordinates </td></tr>
    <tr><td class="paramname">A</td><td>Point A on the triangle </td></tr>
    <tr><td class="paramname">B</td><td>Point B on the triangle </td></tr>
    <tr><td class="paramname">C</td><td>Point C on the triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result coordinates corresponding to the vector coordinates X is A, Y is B, Z is C </dd></dl>

</div>
</div>
<a id="ab03c1f7bd5c47308501d81abcea7eb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03c1f7bd5c47308501d81abcea7eb70">&#9670;&nbsp;</a></span>GetNumTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::GetNumTriangles </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>VectorArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the number of triangles in a vector array in which a tuple of three elements makes up a triangle </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VectorArray</td><td>The array in which each tuple of 3 elements are points of a triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IsValid Returns true if all elements can be associated with a triangle, otherwise returns false </dd>
<dd>
Result The number of triangles available in the array </dd></dl>

</div>
</div>
<a id="a5496b9914485ffe9941105942c566c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5496b9914485ffe9941105942c566c37">&#9670;&nbsp;</a></span>GetTensorDimensionSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::GetTensorDimensionSizes </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>IndexString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets tensor's dimension sizes as an int array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IndexString</td><td>A string representation of the tensor index, each dimension must be separated by | an example for a 5d tensor 1|2|3|4|5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sizes The size of the tensor in each dimension </dd></dl>

</div>
</div>
<a id="ae5b8203e331582eb2c6b8726ab0ad7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b8203e331582eb2c6b8726ab0ad7a6">&#9670;&nbsp;</a></span>GetTensorItem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::GetTensorItem </td>
          <td>(</td>
          <td class="paramtype">UPARAM(ref) TArray&lt; int32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorIndexString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorDimensionSizesString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>Success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ArrayIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets tensor item's value and 1D array index </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Array</td><td>The array intended to be used for this tensor </td></tr>
    <tr><td class="paramname">TensorIndexString</td><td>A string representation of the tensor index, each dimension must be separated by | an example for a 5d tensor 0|1|2|3|4 </td></tr>
    <tr><td class="paramname">TensorDimensionSizesString</td><td>A string representation of the tensor dimension sizes, each dimension must be separated by | an example for a 5d tensor 1|2|3|4|5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success Returns true if the operation succeeded </dd>
<dd>
ArrayIndex 1D array index of the returned tensor item </dd>
<dd>
Result The tensor item's value </dd></dl>

</div>
</div>
<a id="a4e096655d7000040b0b49b321db45f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e096655d7000040b0b49b321db45f1f">&#9670;&nbsp;</a></span>GetTensorSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::GetTensorSize </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>IndexString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets tensor's total size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IndexString</td><td>A string representation of the tensor index, each dimension must be separated by | an example for a 5d tensor 0|1|2|3|4 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size The total size of the tensor </dd></dl>

</div>
</div>
<a id="a95b26c3e5957e730baf0a9814fa15e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b26c3e5957e730baf0a9814fa15e1e">&#9670;&nbsp;</a></span>GetTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::GetTriangle </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>VectorArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>TriangleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets triangle points from vector array in which a tuple of three elements makes up a triangle </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VectorArray</td><td>The array in which each tuple of 3 elements are points of a triangle </td></tr>
    <tr><td class="paramname">TriangleIndex</td><td>The index of the triangle Example: index 1 will return [3] [4] and [5] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Point A on the triangle </dd>
<dd>
B Point B on the triangle </dd>
<dd>
C Point C on the triangle </dd></dl>

</div>
</div>
<a id="af3c73dc69460767159e5e5bf1a054d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c73dc69460767159e5e5bf1a054d9f">&#9670;&nbsp;</a></span>HexToColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::HexToColor </td>
          <td>(</td>
          <td class="paramtype">FString&#160;</td>
          <td class="paramname"><em>Hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts color HEX string to FColor structure </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">HEX</td><td>Color in HEX format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="a762202c1dd6f5aeac63920cb1620a247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762202c1dd6f5aeac63920cb1620a247">&#9670;&nbsp;</a></span>InsertTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::InsertTriangle </td>
          <td>(</td>
          <td class="paramtype">UPARAM(ref) TArray&lt; FVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>VectorArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>Success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a triangle in a vector triangle array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VectorArray</td><td>The array in which each tuple of 3 elements are points of a triangle </td></tr>
    <tr><td class="paramname">A</td><td>The point A of the triangle </td></tr>
    <tr><td class="paramname">B</td><td>The point B of the triangle </td></tr>
    <tr><td class="paramname">C</td><td>The point C of the triangle </td></tr>
    <tr><td class="paramname">Index</td><td>The triangle index at which to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success Is the operation successful (is element inserted) </dd></dl>

</div>
</div>
<a id="ade219249523fbcc6141aa2d8d7ccb882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade219249523fbcc6141aa2d8d7ccb882">&#9670;&nbsp;</a></span>IsAboveActor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::IsAboveActor </td>
          <td>(</td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsAbove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if Actor is above Other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Actor</td><td>The reference actor. </td></tr>
    <tr><td class="paramname">Other</td><td>The other actor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IsAbove Returns true if Actor is above Other. </dd></dl>

</div>
</div>
<a id="a7e2f4e8e1ba5a8f5c8c2919b36f8449b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2f4e8e1ba5a8f5c8c2919b36f8449b">&#9670;&nbsp;</a></span>IsFacingPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::IsFacingPoint </td>
          <td>(</td>
          <td class="paramtype">const FVector &amp;&#160;</td>
          <td class="paramname"><em>Point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVector &amp;&#160;</td>
          <td class="paramname"><em>FacingDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVector &amp;&#160;</td>
          <td class="paramname"><em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsFacing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a point is facing another point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Point</td><td>The reference point. </td></tr>
    <tr><td class="paramname">FacingDirection</td><td>The direction in which the reference point is facing. </td></tr>
    <tr><td class="paramname">Other</td><td>The other point against which to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IsFacing Returns true if Point is facing Other. </dd></dl>

</div>
</div>
<a id="afa924426c153190b03991262fa3a9ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa924426c153190b03991262fa3a9ea6">&#9670;&nbsp;</a></span>IsInFrontOfActor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::IsInFrontOfActor </td>
          <td>(</td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsInFront</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if Actor is in front of Other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Actor</td><td>The reference actor. </td></tr>
    <tr><td class="paramname">Other</td><td>The other actor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IsInFront Returns true if Actor is in front of Other. </dd></dl>

</div>
</div>
<a id="ab8d962686d23768a0da45ee1ad03a55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d962686d23768a0da45ee1ad03a55f">&#9670;&nbsp;</a></span>IsNearActor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::IsNearActor </td>
          <td>(</td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsNear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if Actor is near Other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Actor</td><td>The reference actor. </td></tr>
    <tr><td class="paramname">Other</td><td>The other actor. </td></tr>
    <tr><td class="paramname">Distance</td><td>Below which distance we consider 'is near' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IsNear Returns true if Actor is near Other. </dd></dl>

</div>
</div>
<a id="acf688a165320f737b9bd962a392c5fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf688a165320f737b9bd962a392c5fe5">&#9670;&nbsp;</a></span>IsRightOfActor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::IsRightOfActor </td>
          <td>(</td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if Actor is right of Other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Actor</td><td>The reference actor. </td></tr>
    <tr><td class="paramname">Other</td><td>The other actor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IsRight Returns true if Actor is right of Other. </dd></dl>

</div>
</div>
<a id="a171cafbc1bcec676166460ac18abdd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171cafbc1bcec676166460ac18abdd69">&#9670;&nbsp;</a></span>IsTensorValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::IsTensorValid </td>
          <td>(</td>
          <td class="paramtype">UPARAM(ref) TArray&lt; int32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorIndexString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorDimensionSizesString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsValid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if tensor is valid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Array</td><td>The array intended to be used for this tensor </td></tr>
    <tr><td class="paramname">TensorIndexString</td><td>A string representation of the tensor index, each dimension must be separated by | an example for a 5d tensor 0|1|2|3|4 </td></tr>
    <tr><td class="paramname">TensorDimensionSizesString</td><td>A string representation of the tensor dimension sizes, each dimension must be separated by | an example for a 5d tensor 1|2|3|4|5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IsValid Returns true if this tensor configuration is valid </dd></dl>

</div>
</div>
<a id="aed13e6174058bc79705f2583e7a143d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed13e6174058bc79705f2583e7a143d3">&#9670;&nbsp;</a></span>IsTensorValidFast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::IsTensorValidFast </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorIndexString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorDimensionSizesString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsValid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if tensor is valid without checking the intended array validity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TensorIndexString</td><td>A string representation of the tensor index, each dimension must be separated by | an example for a 5d tensor 0|1|2|3|4 </td></tr>
    <tr><td class="paramname">TensorDimensionSizesString</td><td>A string representation of the tensor dimension sizes, each dimension must be separated by | an example for a 5d tensor 1|2|3|4|5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IsValid Returns true if this tensor configuration is valid </dd></dl>

</div>
</div>
<a id="a7eff3cc5fd81fde1321706fec2a7c03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eff3cc5fd81fde1321706fec2a7c03b">&#9670;&nbsp;</a></span>IsValidTriangleIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::IsValidTriangleIndex </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>VectorArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsValid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a triangle with the specified index exists in a triangle vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VectorArray</td><td>The array in which each tuple of 3 elements are points of a triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index The index of the triangle </dd>
<dd>
IsValid Is there a triangle at the specified index </dd></dl>

</div>
</div>
<a id="a6f06d178c3ee77c07e91ef1ceb682877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f06d178c3ee77c07e91ef1ceb682877">&#9670;&nbsp;</a></span>LightenColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::LightenColor </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>Color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes the input color lighter </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Color</td><td>The color to lighten </td></tr>
    <tr><td class="paramname">Amount</td><td>0.0 to 1.0, the amount to lighten </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="ae6f1e94d8323ccb6b0b585625336708c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f1e94d8323ccb6b0b585625336708c">&#9670;&nbsp;</a></span>MergeArrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::MergeArrays </td>
          <td>(</td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt;&#160;</td>
          <td class="paramname"><em>BaseArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt;&#160;</td>
          <td class="paramname"><em>MergeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString&#160;</td>
          <td class="paramname"><em>FilterFunctionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>MergeOnlyUnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two arrays based on the result of the [FilterFunctionName] defined in Blueprints. Transfers all elements from BaseArray and then merges MergeArray to Base array if the condition in [FilterFunctionName] is satisfied. The BP [FilterFunctionName] must be defined in BP as follows: Inputs: int Index, &lt;InputArrayType&gt; Object; Output: bool RetVal; The BP [FilterFunctionName] will be called each time a filter event happens with the appropriate parameters already set inside the BP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Context</td><td>The actor that is the context of this operation (get Self). </td></tr>
    <tr><td class="paramname">BaseArray</td><td>The array that is the base (completely transfered to the new array) </td></tr>
    <tr><td class="paramname">MergeArray</td><td>Array to be merged if the conditions are satisfied </td></tr>
    <tr><td class="paramname">FilterFunctionName</td><td>The name of the function which determines whether the current element should remain inside the array. @params MergeOnlyUnique If set to true will only merge elements that exist in MergeArray, but not in BaseArray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output The array that is the result of this merge. </dd></dl>

</div>
</div>
<a id="a7427c102bc781bfdc4e5e96be5174eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7427c102bc781bfdc4e5e96be5174eb5">&#9670;&nbsp;</a></span>MixColors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::MixColors </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mixes two colors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="ab64c918f158eed3addbfe3cea70b94f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64c918f158eed3addbfe3cea70b94f0">&#9670;&nbsp;</a></span>MixColorsBiased()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::MixColorsBiased </td>
          <td>(</td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FColor &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FColor &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mixes two colors based on a bias </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First color </td></tr>
    <tr><td class="paramname">B</td><td>Second color </td></tr>
    <tr><td class="paramname">Bias</td><td>Bias value of 0.0 will result with color A, Bias value of 1.0 will result with color B, Bias value of 0.5 will result a 50% mix between colors A and B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result color </dd></dl>

</div>
</div>
<a id="ac58ffd46ff202d063dbbf4a25e19f8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58ffd46ff202d063dbbf4a25e19f8f8">&#9670;&nbsp;</a></span>OffsetPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::OffsetPoint </td>
          <td>(</td>
          <td class="paramtype">const FVector &amp;&#160;</td>
          <td class="paramname"><em>Point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVector &amp;&#160;</td>
          <td class="paramname"><em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets a point by distance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Point</td><td>The point to be offset. </td></tr>
    <tr><td class="paramname">Direction</td><td>The direction in which to offset the point. </td></tr>
    <tr><td class="paramname">Distance</td><td>The distance in which to offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result The result point. </dd></dl>

</div>
</div>
<a id="a4efd264f45a1d21a5dae02efe120368a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efd264f45a1d21a5dae02efe120368a">&#9670;&nbsp;</a></span>QuicksortArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::QuicksortArray </td>
          <td>(</td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt;&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString&#160;</td>
          <td class="paramname"><em>ComparatorFunctionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quicksorts an array based on the result of the [ComparatorFunctionName] defined in Blueprints. Sorts all elements from the input array based on the [ComparatorFunctionName] result. The BP [ComparatorFunctionName] must be defined in BP as follows: Inputs: int lhsIndex, int rhsIndex, &lt;InputArrayType&gt; lhsObject, &lt;InputArrayType&gt; rhsObject; Output: bool RetVal; The BP [ComparatorFunctionName] will be called each time a sort comparison event happens with the appropriate parameters already set inside the BP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Context</td><td>The actor that is the context of this operation (get Self). </td></tr>
    <tr><td class="paramname">Array</td><td>The array that is the subject of filtration. </td></tr>
    <tr><td class="paramname">ComparatorFunctionName</td><td>The name of the function which determines whether the current element should remain inside the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output The sorted array. </dd></dl>

</div>
</div>
<a id="a55b76ade44009f952386010a4a3568b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b76ade44009f952386010a4a3568b6">&#9670;&nbsp;</a></span>RemoveTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::RemoveTriangle </td>
          <td>(</td>
          <td class="paramtype">UPARAM(ref) TArray&lt; FVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>VectorArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>Success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a triangle from a vector triangle array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VectorArray</td><td>The array in which each tuple of 3 elements are points of a triangle </td></tr>
    <tr><td class="paramname">Index</td><td>The triangle index at which to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success Is the operation successful (is element set?) </dd></dl>

</div>
</div>
<a id="a162f9496193731fe1a5d016e13b6f2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162f9496193731fe1a5d016e13b6f2da">&#9670;&nbsp;</a></span>ResizeTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::ResizeTensor </td>
          <td>(</td>
          <td class="paramtype">UPARAM(ref) TArray&lt; int32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>IndexString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the tensor to fit the specified dimensions. Note: All previous tensor data is overwritten with blank data when resizing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Array</td><td>The array intended to be used for this tensor </td></tr>
    <tr><td class="paramname">IndexString</td><td>A string representation of the tensor index, each dimension must be separated by | an example for a 5d tensor 0|1|2|3|4 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57ccc14c55eb96b994a7648bb5ba5158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ccc14c55eb96b994a7648bb5ba5158">&#9670;&nbsp;</a></span>SetTensorItem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::SetTensorItem </td>
          <td>(</td>
          <td class="paramtype">UPARAM(ref) TArray&lt; int32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UPARAM(ref) int32 &amp;&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorIndexString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorDimensionSizesString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>Success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets tensor item's value and 1D array index </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Array</td><td>The array intended to be used for this tensor </td></tr>
    <tr><td class="paramname">Value</td><td>The tensor item's new value </td></tr>
    <tr><td class="paramname">TensorIndexString</td><td>A string representation of the tensor index, each dimension must be separated by | an example for a 5d tensor 0|1|2|3|4 </td></tr>
    <tr><td class="paramname">TensorDimensionSizesString</td><td>A string representation of the tensor dimension sizes, each dimension must be separated by | an example for a 5d tensor 1|2|3|4|5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success Returns true if the operation succeeded </dd></dl>

</div>
</div>
<a id="add63301f79940807d2b305cdea936b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add63301f79940807d2b305cdea936b83">&#9670;&nbsp;</a></span>SetTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::SetTriangle </td>
          <td>(</td>
          <td class="paramtype">UPARAM(ref) TArray&lt; FVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>VectorArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>Success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a triangle in a vector triangle array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VectorArray</td><td>The array in which each tuple of 3 elements are points of a triangle </td></tr>
    <tr><td class="paramname">A</td><td>The point A of the triangle </td></tr>
    <tr><td class="paramname">B</td><td>The point B of the triangle </td></tr>
    <tr><td class="paramname">C</td><td>The point C of the triangle </td></tr>
    <tr><td class="paramname">Index</td><td>The triangle index at which to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success Is the operation successful (is element set) </dd></dl>

</div>
</div>
<a id="a39d76e120177e29a2c7900ea88a1aec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d76e120177e29a2c7900ea88a1aec1">&#9670;&nbsp;</a></span>SiftArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::SiftArray </td>
          <td>(</td>
          <td class="paramtype">const AActor *&#160;</td>
          <td class="paramname"><em>Context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt;&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString&#160;</td>
          <td class="paramname"><em>SeaveFunctionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>OutputL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>OutputR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Seaves an array based on the result of the [SeaveFunctionName] defined in Blueprints. If the BP [SeaveFunctionName] returns true then the current element is 'seaved' in OutputL, otherwise it is 'seaved' inside OutputR. This function is useful when you want to split an array based on a condition. The BP [SeaveFunctionName] must be defined in BP as follows: Inputs: int Index, &lt;InputArrayType&gt; Object; Output: bool RetVal; The BP [SeaveFunctionName] will be called each time a filter event happens with the appropriate parameters already set inside the BP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Context</td><td>The actor that is the context of this operation (get Self). </td></tr>
    <tr><td class="paramname">Array</td><td>The array that is the subject of filtration. </td></tr>
    <tr><td class="paramname">SeaveFunctionName</td><td>The name of the function which determines whether the current element should remain inside the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OutputL The array containing elements that satisfy the [SeaveFunctionName] condition. </dd>
<dd>
OutputR The array containing elements that do not satisfy the [SeaveFunctionName] condition. </dd></dl>

</div>
</div>
<a id="a321f8783e2c883ead1a6d030091065a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321f8783e2c883ead1a6d030091065a9">&#9670;&nbsp;</a></span>TensorToArrayIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UXToolkitCore::TensorToArrayIndex </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorIndexString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>TensorDimensionSizesString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ArrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an n-dimensional tensor index to 1D array index. Returns -1 if it fails to convert </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TensorIndexString</td><td>A string representation of the tensor index, each dimension must be separated by | an example for a 5d tensor 0|1|2|3|4 </td></tr>
    <tr><td class="paramname">TensorDimensionSizesString</td><td>A string representation of the tensor dimension sizes, each dimension must be separated by | an example for a 5d tensor 1|2|3|4|5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ArrayIndex 1D array index corresponding to input tensor index </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
